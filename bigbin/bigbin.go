// bigbib tool modifies your mains and generates their standalone versions as well as the bigbin to invoke all
// on a single big binary
//
// Benefits:
// 1) A single binary to install multiple programs (plus symbolic links to it with each program name)
// 2) A single binary means a single copy of the runtime and libraries used to store and load into memory
//  - Less disk space reuired in tight systems
//  - Less memory to load and faster loading on subsequent invocations of other programs in teh same bigbin
//
// How to use:
//
// $ bigbin [-dir bigbin-package-directory] directories...
//
// It will generate, for each directory:
//
// 1) If the directory does not contain a main, an error will be dumped and the directory wonÂ´t be processed.
// Otherwise...
//
// 2) Rename in all *.go files the directory package from main to the name appname (=last name on the directory path)
//
// 3) Rename func main() {...} to func Main() {...}
//
// 4) Add an autoregistration within the init() func (creatign the init if missing) alongside func Main() {...} such as:
//
//   package {appname}
//
//   ...
//
//   import "github.com/josvazg/bigbin"
//
//   ...
//
//   func init() {
//             bigbin.Add("{appname}", Main)
//   }
//
// 5) A standalone main will be generated at directory/main such as:
//
//   package main
//
//   import "{directory import path}"
//
//   func main() {
//              {appname}.Main()
//   }
//
// After processing all directories the bigbin main is created at bigbin-package-directory such as:
//
//   package main
//
//   import (
//              "github.com/josvazg/bigbin"
//              _ "{directory1 import path}"
//              ...
//              _ "{directoryN import path}"
//   )
//
//   func main() {
//		bigbin.Main()
//   }
//
// Note that bigbin won't try to rename directories packages such as .../cmd or .../main but you might want to rename
// them to something more usegul and less confusing, specially if you end up with .../main/main due to the standalone

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func init() {
	// nothing really
}

func init() {
	_ = 0
}

const AutoRegister = `// Autogenerated by BigBig: Autoregister code
package %s

import "github.com/josvazg/bigbin"

func init() {
	bigbin.Add("%s", Main)
}`

const BigBin = `// Autogenerated BigBinary main: Don't edit, use bigbin tool to regenerate
// (c) josvazg@gmail.com

package main

import (
    "github.com/josvazg/bigbin"
    %s
)

func main() {
    bigbin.Main()
}
`

const StandAlone = `// Autogenerated Standalone main for %s
package main 

import "%s"

func main() {
    %s.Main()
}
`

// Generate is the main entry point that generates the BigBin and changes user's source code
func Generate(outdir string, dirs ...string) {
	generatedSrcs := make(map[string][]byte)
	_ = mkdirs(outdir)
	for _, dir := range dirs {
		if srcs, err := processDir(dir); err != nil {
			fmt.Printf("Error processing directory %s:\n%s", dir, err)
		} else {
			for filename, src := range srcs {
				generatedSrcs[filename] = src
			}
		}
	}
	if filename, src, err := genBigBin(outdir, dirs...); err != nil {
		fmt.Printf("Couldn't generate bigbin main: %v", err)
	} else {
		generatedSrcs[filename] = src
	}
	for filename, src := range generatedSrcs {
		fmt.Printf("%s:\n", filename)
		fmt.Println(string(src))
	}
}

// mkdirs will create outdir if it does not exist or fail the application if it could not create it
func mkdirs(outdir string) *os.File {
	var err error
	_, err = os.Stat(outdir)
	if err != nil {
		err = os.MkdirAll(outdir, 0750)
	}
	var file *os.File
	if file, err = os.Open(outdir); err != nil {
		panic(err)
	}
	return file
}

// processDir will check for dir and try to turn the code in there to be a package invokable by bigbin
func processDir(dir string) (map[string][]byte, error) {
	generatedSrcs := make(map[string][]byte)
	fileset := token.NewFileSet()
	packages, err := parser.ParseDir(fileset, dir, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("Couldn't parse directory %s:%v", dir, err)
	}
	packageName := filepath.Base(dir)
	for pkg, astpkg := range packages {
		if pkg != "main" {
			return nil, fmt.Errorf("%s expected to be 'main' but was %s! Skipped", dir, pkg)
		}
		for filename, astfile := range astpkg.Files {
			astfile.Name = ast.NewIdent(packageName)
			renameMain(astfile)
			if src, err := toSource(astfile); err != nil {
				return nil, fmt.Errorf("Couldn't gofmt astfile: %v", err)
			} else {
				generatedSrcs[filepath.Join(dir, filename)] = src
			}
		}
		autoregisterFilename := fmt.Sprintf("%s_autoregister.go", packageName)
		_, ok := astpkg.Files[autoregisterFilename]
		if !ok {
			rawsrc := fmt.Sprintf(AutoRegister, packageName, filepath.Base(dir))
			if src, err := formatSource(rawsrc); err != nil {
				return nil, fmt.Errorf("Couldn't process & gofmt source:\n%s\nError was: %v", rawsrc, err)
			} else {
				generatedSrcs[filepath.Join(dir, autoregisterFilename)] = src
			}
		}
	}
	if filename, src, err := genStandAlone(dir); err != nil {
		return nil, fmt.Errorf("Couldn't add standalone main: %v", err)
	} else {
		generatedSrcs[filename] = src
	}
	return generatedSrcs, nil
}

// toSource gets the go fmt source form of file or an error
func toSource(file *ast.File) ([]byte, error) {
	buf := bytes.NewBufferString("")
	if err := format.Node(buf, token.NewFileSet(), file); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// formatSource formats and validates the source src into a valid go fmtd source
func formatSource(src string) ([]byte, error) {
	return format.Source(([]byte)(src))
}

// genStandAlone adds a stand alone main invocation at dir
func genStandAlone(dir string) (string, []byte, error) {
	packageName := filepath.Base(dir)
	packagePath, err := pkgpath(dir)
	mainfilename := filepath.Join(dir, "main", "main.go")
	var mainfile *os.File
	mainfile, err = os.Open(mainfilename)
	if err != nil {
		_, missingFile := err.(*os.PathError)
		if missingFile {
			if err := os.MkdirAll(filepath.Dir(mainfilename), 0750); err != nil {
				return "", nil, err
			}
			rawsrc := fmt.Sprintf(StandAlone, packagePath, packagePath, packageName)
			if src, err := formatSource(rawsrc); err != nil {
				return "", nil, fmt.Errorf("Couldn't process & gofmt source:\n%s\nError was: %v", rawsrc, err)
			} else {
				return mainfilename, src, nil
			}
		}
		return "", nil, err
	}
	mainfile.Close()
	return "", nil, fmt.Errorf("Standalone %s already present, it won't be modified", mainfilename)
}

// pkgpath extract the package path of the given directory
func pkgpath(dir string) (pkgpath string, err error) {
	pkgpath, err = filepath.Abs(dir)
	if err != nil {
		return "", err
	}
	prefix := filepath.Join(os.Getenv("GOPATH"), "src")
	if !strings.HasPrefix(pkgpath, prefix) {
		return "", fmt.Errorf("%d was expected within GOPATH source dir '%s' but it is not!", pkgpath, prefix)
	}
	return pkgpath[len(prefix)+1:], nil
}

func dieOnError(err error) {
	if err != nil {
		fmt.Println(err)
		os.Exit(-1)
	}
}

// renameMain turns 'main' (if present) to 'Main', and returns true if astfile was changed
func renameMain(astfile *ast.File) bool {
	for _, decl := range astfile.Decls {
		fndecl, ok := (decl).(*ast.FuncDecl)
		if ok && fndecl.Name.Name == "main" {
			fndecl.Name = ast.NewIdent("Main")
			return true
		}
	}
	return false
}

// genBigBin generates the big binary main for apps at outdir
func genBigBin(outdir string, dirs ...string) (string, []byte, error) {
	bigbin := filepath.Join(outdir, "main.go")
	var f *os.File
	f, err := os.Open(bigbin)
	if err != nil {
		_, missingFile := err.(*os.PathError)
		if missingFile {
			if err := os.MkdirAll(filepath.Dir(bigbin), 0750); err != nil {
				return "", nil, err
			}
			if imports, err := toImports(dirs); err != nil {
				return "", nil, err
			} else {
				rawsrc := fmt.Sprintf(BigBin, imports...)
				if src, err := formatSource(rawsrc); err != nil {
					return "", nil, fmt.Errorf("Couldn't process & gofmt source:\n%s\nError was: %v", rawsrc, err)
				} else {
					return bigbin, src, nil
				}
			}
		}
		return "", nil, err
	}
	f.Close()
	return "", nil, fmt.Errorf("BigBin %s already present, it won't be modified", bigbin)
}

// toImports converts the list of directories into a list of empty canonical package path imports
func toImports(dirs []string) ([]interface{}, error) {
	emptyImports := make([]interface{}, 0, len(dirs))
	for _, dir := range dirs {
		if pkgpath, err := pkgpath(dir); err != nil {
			return nil, err
		} else {
			emptyImports = append(emptyImports, fmt.Sprintf("_ \"%s\"\n", pkgpath))
		}
	}
	return emptyImports, nil
}

func main() {
	Generate("test/", "../sample")
}
