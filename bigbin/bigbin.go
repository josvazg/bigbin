// bigbib tool modifies your mains and generates their standalone versions as well as the bigbin to invoke all
// on a single big binary
//
// Benefits:
// 1) A single binary to install multiple programs (plus symbolic links to it with each program name)
// 2) A single binary means a single copy of the runtime and libraries used to store and load into memory
//  - Less disk space reuired in tight systems
//  - Less memory to load and faster loading on subsequent invocations of other programs in teh same bigbin
//
// How to use:
//
// $ bigbin [-dir bigbin-package-directory] directories...
//
// It will generate, for each directory:
//
// 1) If the directory does not contain a main, an error will be dumped and the directory wonÂ´t be processed.
// Otherwise...
//
// 2) Rename in all *.go files the directory package from main to the name appname (=last name on the directory path)
//
// 3) Rename func main() {...} to func Main() {...}
//
// 4) Add an autoregistration within the init() func (creating the init if missing) alongside func Main() {...} such as:
//
//   package {appname}
//
//   ...
//
//   import "github.com/josvazg/bigbin"
//
//   ...
//
//   func init() {
//             bigbin.Add("{appname}", Main)
//   }
//
// 5) A standalone main will be generated at directory/main such as:
//
//   package main
//
//   import "{directory import path}"
//
//   func main() {
//              {appname}.Main()
//   }
//
// After processing all directories the bigbin main is created at bigbin-package-directory such as:
//
//   package main
//
//   import (
//              "github.com/josvazg/bigbin"
//              _ "{directory1 import path}"
//              ...
//              _ "{directoryN import path}"
//   )
//
//   func main() {
//		bigbin.Main()
//   }
//
// Note that bigbin won't try to rename directories packages such as .../cmd or .../main but you might want to rename
// them to something more usegul and less confusing, specially if you end up with .../main/main due to the standalone

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

const (
	AutoRegister = `// Autogenerated by BigBig: Autoregister code
package %s

import "github.com/josvazg/bigbin"

func init() {
	bigbin.Add("%s", Main)
}`

	BigBin = `// Autogenerated BigBinary main: Don't edit, use bigbin tool to regenerate
// (c) josvazg@gmail.com

package main

import (
    "github.com/josvazg/bigbin"
    %s
)

func main() {
    bigbin.Main()
}
`
	StandAlone = `// Autogenerated Standalone main for %s
package main 

import "%s"

func main() {
    %s.Main()
}
`

	AutoregisterSuffix = "_autoregister.go"
)

// mkdirs will create outdir if it does not exist or fail the application if it could not create it
/*func mkdirs(outdir string) *os.File {
	var err error
	_, err = os.Stat(outdir)
	if err != nil {
		err = os.MkdirAll(outdir, 0750)
	}
	var file *os.File
	if file, err = os.Open(outdir); err != nil {
		panic(err)
	}
	return file
}*/

/*
func dieOnError(err error) {
	if err != nil {
		fmt.Println(err)
		os.Exit(-1)
	}
}*/

type sources struct {
	srcs map[string][]byte
	err  error
}

// newSources generates a new sources type for processing and generating code
func newSources() *sources {
	return &sources{srcs: make(map[string][]byte)}
}

// addFixedMains will generate code to fix files in dir so that:
//
// "package main" -> "package {pkgname}" & "func main()" -> "func Main()"
//
// The generated sources are added srcs.
//
// It will register an error if something goes wrong, like a package is not named as expected,
// some package was missing any func Main or func mains or the generated code failed validation.
func (srcs *sources) addFixedMainsFrom(dir string) {
	if srcs.err != nil {
		return
	}
	fileset := token.NewFileSet()
	packages, err := parser.ParseDir(fileset, dir, nil, parser.ParseComments|parser.AllErrors)
	if err != nil {
		srcs.err = fmt.Errorf("Couldn't parse directory %s:%v", dir, err)
		return
	}
	packageName := packageName(dir)
	for pkg, astpkg := range packages {
		if pkg != "main" && pkg != packageName {
			srcs.err = fmt.Errorf("%s expected to be 'main' or already %s but was %s!", dir, packageName, pkg)
			return
		}
		mainFound := false
		for filename, astfile := range astpkg.Files {
			astfile.Name = ast.NewIdent(packageName)
			mainFound = mainFound || renameMain(astfile)
			if src, err := gofmt(fileset, astfile); err != nil {
				srcs.err = fmt.Errorf("Couldn't gofmt astfile: %v", err)
				return
			} else {
				srcs.srcs[filepath.Join(dir, filename)] = src
			}
		}
		if !mainFound {
			srcs.err = fmt.Errorf("Package %s is missing any func main or Main!", packageName)
			return
		}
	}
}

// addAutoregistrationTo generates an autoregistration init for the ginven directory's packages
func (srcs *sources) addAutoregistrationTo(dir string) {
	if srcs.err != nil {
		return
	}
	packageName := packageName(dir)
	autoregisterFilename := fmt.Sprintf("%s_autoregister.go", packageName)
	// first assume the file does not exist and generate it
	if src, err := compose(AutoRegister, packageName, filepath.Base(dir)); err != nil {
		srcs.err = fmt.Errorf("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[filepath.Join(dir, autoregisterFilename)] = src
	}
}

// addStandAlone adds a stand alone main invocation as a subpackage at dir
func (srcs *sources) addStandAlone(dir string) {
	if srcs.err != nil {
		return
	}
	packageName := packageName(dir)
	packagePath, err := pkgpath(dir)
	if err != nil {
		srcs.err = fmt.Errorf("Couldn't get package path for %s: %v", dir, err)
		return
	}
	mainFilename := filepath.Join(dir, "main", "main.go")
	if src, err := compose(StandAlone, packagePath, packagePath, packageName); err != nil {
		srcs.err = fmt.Errorf("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[mainFilename] = src
	}
}

// addAutoregistrationTo generates an autoregistration init for the ginven directory's packages
func (srcs *sources) addBigBinMain(outdir string, dirs []string) {
	if srcs.err != nil {
		return
	}
	bigbin := filepath.Join(outdir, "main.go")
	if imports, err := toImports(dirs); err != nil {
		srcs.err = fmt.Errorf("Couldn't process imports: %v", err)
		return
	} else if src, err := compose(BigBin, imports...); err != nil {
		srcs.err = fmt.Errorf("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[bigbin] = src
	}
}

// compose generates a source file in proper go fmt form,
// or fails trying returning a non nil error
func compose(src string, args ...interface{}) ([]byte, error) {
	code := fmt.Sprintf(src, args...)
	gofmted, err := format.Source(([]byte)(code))
	if err != nil {
		return nil, fmt.Errorf("Error validating source:\n%s\n\n%v", code, err)
	}
	return gofmted, nil
}

// packageName derives a package name from the directory
func packageName(dir string) string {
	return filepath.Base(dir)
}

// toImports converts the list of directories into a list of empty canonical package path imports
func toImports(dirs []string) ([]interface{}, error) {
	emptyImports := make([]interface{}, 0, len(dirs))
	for _, dir := range dirs {
		if pkgpath, err := pkgpath(dir); err != nil {
			return nil, err
		} else {
			emptyImports = append(emptyImports, fmt.Sprintf("_ \"%s\"\n", pkgpath))
		}
	}
	return emptyImports, nil
}

// pkgpath extract the package path of the given directory
func pkgpath(dir string) (pkgpath string, err error) {
	pkgpath, err = filepath.Abs(dir)
	if err != nil {
		return "", err
	}
	prefix := filepath.Join(os.Getenv("GOPATH"), "src")
	if !strings.HasPrefix(pkgpath, prefix) {
		return "", fmt.Errorf("%d was expected within GOPATH source dir '%s' but it is not!", pkgpath, prefix)
	}
	return pkgpath[len(prefix)+1:], nil
}

// Generate takes the following inputs:
//
// - bigBinDir; the directory in where to generate the big binary
//
// - mainDirs; the list of mains packages that need to be turn into big binary's applets
//
// And with that returns either:
//
// - An error, if something goes wrong
//
// - Or a map of sources containing all files needed to generate the big binary code
//
// It supports being called upon files already modified by a previous call to Generate.
// In that case, it will generate the modified file unless if finds inconsistencies in files to be modified,
// like lacking a main or Main function or having an unexpected package name
func Generate(bigBinDir string, mainDirs ...string) (map[string][]byte, error) {
	srcs := newSources()
	for _, dir := range mainDirs {
		srcs.addFixedMainsFrom(dir)
		srcs.addAutoregistrationTo(dir)
		srcs.addStandAlone(dir)
	}
	// add the big binary main at bigBinDir
	srcs.addBigBinMain(bigBinDir, mainDirs)
	if srcs.err != nil {
		return nil, srcs.err
	}
	return srcs.srcs, nil
}

// renameMain modifies astfile with 'func main' (if present) renamed to 'func Main'.
// Resturns true if the file got main renamed to Main or had it renamed beforehand
func renameMain(astfile *ast.File) bool {
	for _, decl := range astfile.Decls {
		fndecl, ok := (decl).(*ast.FuncDecl)
		if ok && fndecl.Name.Name == "main" {
			fndecl.Name = ast.NewIdent("Main")
		}
		if ok && fndecl.Name.Name == "Main" {
			return true // if main was changed here or beforehand we return true
		}
	}
	return false
}

// gofmt turns the fiven AST file into a go fmted source bytes.
// Or returns nil and an error is something fails
func gofmt(fileset *token.FileSet, file *ast.File) ([]byte, error) {
	buf := bytes.NewBufferString("")
	if err := format.Node(buf, fileset, file); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func main() {
	srcs, err := Generate("test/", "../sample")
	if err != nil {
		fmt.Println("Generate error: %v\n", err)
		os.Exit(-1)
	}
	bar := "\n=================================================\n"
	for filename, src := range srcs {
		fmt.Printf("%s:%s%s%s\n\n", filename, bar, string(src), bar)
	}
}
