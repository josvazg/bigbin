package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const (
	Header = "// Do NOT edit manually! Autogenerated by github.com/josvazg/bigbin/generator: "

	AutoRegister = Header + `Autoregister code
package %s

import "github.com/josvazg/bigbin"

func init() {
	bigbin.Add("%s", Main)
}`

	BigBin = Header + `bigbin main"

package main

import (
    "github.com/josvazg/bigbin"
    %s
)

func main() {
    bigbin.Main()
}
`

	StandAlone = Header + `Standalone main for %s
package main 

import "%s"

func main() {
    %s.Main()
}
`

	AutoregisterSuffix = "_autoregister.go"

	SourcesSeparator = "\n=================================================\n"
)

// Sources bundles all sources to be modified (or the errors found) by this generator package.
// Sources is inmmutable from consumers outside the package so no threading protection is required.
type Sources struct {
	srcs   map[string][]byte
	errors []error
}

// Generate takes the following inputs:
//
// - bigBinDir; the directory in where to generate the big binary (if empty it won't generate it)
//
// - mainDirs; the list of main packages that need to be turn into big binary's applets
//
// And it returns a Sources object with all source modifications or all errors found in the process.
//
// Generate is idempotent, it supports being called upon files already modified by a previous invocation.
// It always generates exactly the same set of sources code changes (in absence of errors).
func Generate(bigBinDir string, mainDirs ...string) *Sources {
	srcs := newSources()
	for _, dir := range mainDirs {
		srcs.addFixedMains(dir)
		srcs.addAutoregistration(dir)
		srcs.addStandAlone(dir)
	}
	if bigBinDir != "" {
		srcs.addBigBinMain(bigBinDir, mainDirs)
	}
	return srcs
}

// Restore does the opposite to Generate, creates the sources so that code can return to its state
// previous to a call to Generate:
//
// - Files created by Generate will be marked for removal
//
// - Modifications by Generate will be reverted
//
// - BigBird is only removed is bigBinDir is non empty
//
// Restore, like Generate, is also idempotent.
func Restore(bigBinDir string, mainDirs ...string) *Sources {
	srcs := newSources()
	for _, dir := range mainDirs {
		srcs.addRestoredMains(dir)
		srcs.removeAutoregistration(dir)
		srcs.removeStandAlone(dir)
	}
	if bigBinDir != "" {
		srcs.removeBigBinMain(bigBinDir, mainDirs)
	}
	return srcs
}

// Dump Sources to a string
func (srcs *Sources) String() string {
	buf := bytes.NewBufferString("")
	for filename, src := range srcs.srcs {
		fmt.Fprintf(buf, "%s:%s%s%s\n\n", filename, SourcesSeparator, string(src), SourcesSeparator)
	}
	return buf.String()
}

// Errors returns the errors registered within Sources, if any
func (srcs *Sources) Errors() []error {
	return srcs.errors
}

// Apply sources changes on the filesystem.
//
// Modified files are overwrittten right away.
// Newly generated files are created, alongside with required directories
//
// Returns nil if all changes where applied or an (IO related) error if something went wrong
func (srcs *Sources) Apply() error {
	for filename, src := range srcs.srcs {
		if src != nil {
			dir := filepath.Dir(filename)
			if err := os.MkdirAll(dir, 755); err != nil {
				return err
			}
			file, err := os.Create(filename)
			if err != nil {
				return err
			}
			defer file.Close()
			if _, err := io.WriteString(file, string(src)); err != nil {
				return err
			}
		} else {
			if err := os.Remove(filename); err != nil && !os.IsNotExist(err) {
				return err
			}
		}
	}
	return nil
}

// newSources generates a new sources type for processing and generating code
func newSources() *Sources {
	return &Sources{srcs: make(map[string][]byte)}
}

// addFixedMains will generate code to fix files in dir so that:
//
// "package main" -> "package {pkgname}" & "func main()" -> "func Main()"
//
// The generated sources are added srcs.
//
// It will register an error if something goes wrong, like a package is not named as expected,
// some package was missing any func Main or func mains or the generated code failed validation.
func (srcs *Sources) addFixedMains(dir string) {
	fileset := token.NewFileSet()
	packages, err := parser.ParseDir(fileset, dir, nil, parser.ParseComments|parser.AllErrors)
	if err != nil {
		srcs.fail("Couldn't parse directory %s:%v", dir, err)
		return
	}
	packageName := packageName(dir)
	for pkg, astpkg := range packages {
		if pkg != "main" && pkg != packageName {
			srcs.fail("%s expected to be 'main' or already %s but was %s!", dir, packageName, pkg)
			return
		}
		mainFound := false
		for filename, astfile := range astpkg.Files {
			astfile.Name = ast.NewIdent(packageName)
			mainFound = mainFound || renameFunc(astfile, "main", "Main")
			if src, err := gofmt(fileset, astfile); err != nil {
				srcs.fail("Couldn't gofmt astfile: %v", err)
				return
			} else {
				srcs.srcs[filepath.Join(dir, filename)] = src
			}
		}
		if !mainFound {
			srcs.fail("Package %s is missing any func main or Main!", packageName)
			return
		}
	}
}

// addRestoredMains will generate code to undo the changes by addFixedMains:
//
// "package {pkgname}" -> "package main" & "func Main()" -> "func main()"
func (srcs *Sources) addRestoredMains(dir string) {
	fileset := token.NewFileSet()
	packages, err := parser.ParseDir(fileset, dir, nil, parser.ParseComments|parser.AllErrors)
	if err != nil {
		srcs.fail("Couldn't parse directory %s:%v", dir, err)
		return
	}
	packageName := packageName(dir)
	for pkg, astpkg := range packages {
		if pkg != "main" && pkg != packageName {
			srcs.fail("%s expected to be alredy 'main' or %s but was %s!", dir, packageName, pkg)
			return
		}
		mainFound := false
		for filename, astfile := range astpkg.Files {
			astfile.Name = ast.NewIdent("main")
			mainFound = mainFound || renameFunc(astfile, "Main", "main")
			if src, err := gofmt(fileset, astfile); err != nil {
				srcs.fail("Couldn't gofmt astfile: %v", err)
				return
			} else {
				srcs.srcs[filepath.Join(dir, filename)] = src
			}
		}
		if !mainFound {
			srcs.fail("Package %s is missing any func main or Main!", packageName)
			return
		}
	}
}

// addAutoregistration generates an autoregistration init in the given directory package
func (srcs *Sources) addAutoregistration(dir string) {
	packageName := packageName(dir)
	autoregisterFilename := fmt.Sprintf("%s_autoregister.go", packageName)
	if src, err := compose(AutoRegister, packageName, filepath.Base(dir)); err != nil {
		srcs.fail("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[filepath.Join(dir, autoregisterFilename)] = src
	}
}

// removeAutoregistration marks an autoregistration init for deletion in the given directory package
func (srcs *Sources) removeAutoregistration(dir string) {
	autoregisterFilename := fmt.Sprintf("%s_autoregister.go", packageName)
	srcs.srcs[filepath.Join(dir, autoregisterFilename)] = nil
}

// addStandAlone adds a stand alone main invocation as a subpackage at dir
func (srcs *Sources) addStandAlone(dir string) {
	packageName := packageName(dir)
	packagePath, err := pkgpath(dir)
	if err != nil {
		srcs.fail("Couldn't get package path for %s: %v", dir, err)
		return
	}
	mainFilename := filepath.Join(dir, "main", "main.go")
	if src, err := compose(StandAlone, packagePath, packagePath, packageName); err != nil {
		srcs.fail("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[mainFilename] = src
	}
}

// removeStandAlone marks for deletion a stand alone main invocation in subpackage at dir
func (srcs *Sources) removeStandAlone(dir string) {
	mainFilename := filepath.Join(dir, "main", "main.go")
	srcs.srcs[mainFilename] = nil
}

// addBigBinMain generates an BigBinary main the given directories' packages
func (srcs *Sources) addBigBinMain(outdir string, dirs []string) {
	bigbin := filepath.Join(outdir, "main.go")
	if imports, err := toImports(dirs); err != nil {
		srcs.fail("Couldn't process imports: %v", err)
		return
	} else if src, err := compose(BigBin, imports...); err != nil {
		srcs.fail("Couldn't process & gofmt source: %v", err)
		return
	} else {
		srcs.srcs[bigbin] = src
	}
}

// removeBigBinMain marks the BigBinaryMain for deletion
func (srcs *Sources) removeBigBinMain(outdir string, dirs []string) {
	bigbin := filepath.Join(outdir, "main.go")
	srcs.srcs[bigbin] = nil
}

// fail composes and appends a new error to the registered errors, creating the list if this is if first ocurrence
func (srcs *Sources) fail(format string, args ...interface{}) {
	srcs.errors = append(srcs.errors, fmt.Errorf(format, args...))
}

// compose generates a source file in proper go fmt form,
// or fails trying returning a non nil error
func compose(src string, args ...interface{}) ([]byte, error) {
	code := fmt.Sprintf(src, args...)
	gofmted, err := format.Source(([]byte)(code))
	if err != nil {
		return nil, fmt.Errorf("Error validating source:\n%s\n\n%v", code, err)
	}
	return gofmted, nil
}

// packageName derives a package name from the directory
func packageName(dir string) string {
	return filepath.Base(dir)
}

// toImports converts the list of directories into a list of empty canonical package path imports
func toImports(dirs []string) ([]interface{}, error) {
	emptyImports := make([]interface{}, 0, len(dirs))
	for _, dir := range dirs {
		if pkgpath, err := pkgpath(dir); err != nil {
			return nil, err
		} else {
			emptyImports = append(emptyImports, fmt.Sprintf("_ \"%s\"\n", pkgpath))
		}
	}
	return emptyImports, nil
}

// pkgpath extract the package path of the given directory
func pkgpath(dir string) (pkgpath string, err error) {
	pkgpath, err = filepath.Abs(dir)
	if err != nil {
		return "", err
	}
	prefix := filepath.Join(os.Getenv("GOPATH"), "src")
	if !strings.HasPrefix(pkgpath, prefix) {
		return "", fmt.Errorf("%d was expected within GOPATH source dir '%s' but it is not!", pkgpath, prefix)
	}
	return pkgpath[len(prefix)+1:], nil
}

// renameFunc modifies astfile with 'func {oldname}' (if present) renamed to 'func {newname}'.
// Resturns true if the file got renamed and contained either newname or oldname
func renameFunc(astfile *ast.File, oldname, newname string) bool {
	for _, decl := range astfile.Decls {
		fndecl, ok := (decl).(*ast.FuncDecl)
		if ok {
			if fndecl.Name.Name == oldname {
				fndecl.Name = ast.NewIdent(newname)
			}
			if fndecl.Name.Name == newname {
				return true // if the func was renamed here or beforehand we return true
			}
		}
	}
	return false
}

// gofmt turns the fiven AST file into a go fmted source bytes.
// Or returns nil and an error is something fails
func gofmt(fileset *token.FileSet, file *ast.File) ([]byte, error) {
	buf := bytes.NewBufferString("")
	if err := format.Node(buf, fileset, file); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
